მთავარ კონტენტზე გადასვლა
Google Classroom
Classroom
BTU- Mentorship program
Front-End Development
ლექცია 11
Nino Sopoian
•
17 სექ
ფუნქციები

script.js
JavaScript
კლასის კომენტარები

კლასზე კომენტარის დამატება…

ლექცია 11
// რა არის ფუნქციები?
//  ________
// |        |
// |        |
// |        |
// |________|

/*
ფართობი = სიგრძე * სიგანე
const width = 10;
const height = 6;
const area = width * height;
console.log(area);

თუ გვინდა  სამი სხვადასხვა მართკუთხედის ფართობის გამოთვლას:
მაშინ ზედა მოქმედება 3ჯერ უნდა შევასრულოთ. 

იმის ნაცვლად, რომ ერთი და იგივე კოდი თავიდან დავწეროთ, შეგვიძლია ეს კოდი ერთ ბლოკად მოვათავსოთ და დავუკავშიროთ კონკრეტულ ამოცანას. შემდეგ კი გამოვიყენოთ ეს ბლოკი როცა მოგვინდება მისი შესრულება.

ეს ბლოკი არის ფუნქცია — ხელახალი გამოყენებადი კოდის ჯგუფი, რომელიც აერთიანებს ინსტრუქციების თანმიმდევრობას კონკრეტული ამოცანის შესასრულებლად.

*/

// ფუნქციის გამოცხადების 3 მეთოდი
// 1 –  function declaration
// 2– Function Expressions
//3 – Arrow Functions – ES6
//////////////////////////////////
// 1 –  function declaration

// function greetWord() {
//   console.log("hello, world");
// }
// greetWord();

///
// Hoisting გვაძლევს საშუალებას, ფუნქციას მივწვდეთ მანამ, სანამ ის კოდში გამოცხადებული იქნება.
// თუმცა, hoisting-ით სარგებლობა კარგ პრაქტიკად არ ითვლება, ამიტომ მხოლოდ ინფორმაციისთვის უნდა ვიცოდეთ.

//////////////////////
// სავარჯიშო
// ონლაინ მაღაზიისთვის – როცა მომხმარებელი შეკვეთას აკეთებს, გვინდა მადლობის შეტყობინება გავუგზავნოთ.

// შექმენი ფუნქცია სახელად sayThanks() function declaration-ით.
// function sayThanks(name) {
//   console.log("გმადლობთ შეკვეთისთვის! ვაფასებთ თქვენს ნდობას."+name);
// }

// sayThanks("nino");


// ფუნქციის სხეულში ჩაწერე კოდი, რომელიც კონსოლში დაბეჭდავს ტექსტს:
// 'გმადლობთ შეკვეთისთვის! ვაფასებთ თქვენს ნდობას.'

// გამოძახე ფუნქცია, რათა კონსოლში დაინახო ეს შეტყობინება.

// ფუნქცია შეგვიძლია გამოვიძახოთ რამდენჯერაც საჭიროა.
// წარმოიდგინე, სამი მომხმარებელი აკეთებს შეკვეთას — განაახლე კოდი ისე, რომ sayThanks() გამოიძახო სამჯერ.

//////////////////////////////////////////

/*
პარამეტრები და არგუმენტები (Parameters & Arguments)

ფუნქციებს ხშირად სჭირდებათ მონაცემები, რათა კონკრეტული ამოცანა შეასრულონ.
ამ მონაცემების გადასაცემად ვიყენებთ პარამეტრებს და არგუმენტებს.

პარამეტრები (Parameters)

პარამეტრები არის დროებითი ცვლადები, რომლებიც ფუნქციაში წერია ფრჩხილებში.
ისინი მუშაობენ როგორც ადგილების შემავსებლები, სანამ ფუნქციას ნამდვილ მნიშვნელობებს არ გადავცემთ.


function calculateArea(width, height) {
  console.log(width * height);
}

არგუმენტები (Arguments)

არგუმენტები არის რეალური მნიშვნელობები, რომლებიც ფუნქციას გადაეცემა გამოძახების დროს.
მნიშვნელობები () შიგნით იწერება იმავე რიგითობით, რა რიგითობითაც გამოცხადებულია პარამეტრები.

მაგალითი:  calculateArea(10, 6);
////


არგუმენტებად შეგვიძლია გადავცეთ ცვლადებიც:
const rectWidth = 10;
const rectHeight = 6;

calculateArea(rectWidth, rectHeight);
 
რატომ არის ეს მნიშვნელოვანი!

პარამეტრების წყალობით ფუნქციები უფრო მოქნილი და ხელახლა გამოსაყენებელი ხდება.
მაგალითად, calculateArea()-ს შეგვიძლია გამოვიყენოთ ნებისმიერი მართკუთხედის ფართობის გამოსათვლელად, უბრალოდ გადავცემთ სხვადასხვა მნიშვნელობებს არგუმენტებად. */
////////////////////////////////////////////

// სავარჯიშო
// sayThanks() ფუნქციას დავუმატოთ პარამეტრი, რათა შევძლოთ მომხმარებლის სახელის შეტყობინებაში გამოყენება.


// function sayThanks(myname="უცნობი") {
//   console.log("გმადლობთ შეკვეთისთვის! ვაფასებთ თქვენს ნდობას." + myname);
// }
// let yourname = "hjjfjf";

// sayThanks();

/////////////////////////////////////////////////////////////////
// Default Parameters
// ES6-დან JavaScript-ში დაემატა ფუნქციის პარამეტრებისთვის წინასწარ განსაზღვრული მნიშვნელობების გამოყენების შესაძლებლობა.

// function greeting(name = 'stranger') {
//   console.log(`Hello, ${name}!`);
// }

// greeting('Nick');
// greeting();

/////////////////////////////////

// // დავალება
// ფუნქცია რომელიც ქმნის სასურველი პროდუქტების სიას.

// წარმოიდგინე, რომ ყოველთვის ვყიდულობთ რძეს, პურს და კვერცხს.
// პროცესის გასამარტივებლად, ამ პროდუქტებს default მნიშვნელობებად დავაწესებთ.

// function makeShoppingList(item1, item2, item3) {
//   console.log(`გახსოვდეს, იყიდო ${item1}`);
//   console.log(`გახსოვდეს, იყიდო ${item2}`);
//   console.log(`გახსოვდეს, იყიდო ${item3}`);
// }
////////////////////////////////////////////////////////

// Return
// გზა, რომ ფუნქციამ შედეგი მოგვცეს უკან.
// თუ ფუნქცია არაფერს აბრუნებს, შედეგად მივიღებთ undefined.

// მაგალითი:

// function rectangleArea(width, height) {
//   let area = width * height;
//   return area;
// }
// let result = rectangleArea(5, 7);
// // console.log(rectangleArea(5, 7));

// ფუნქციამ ფართობი გამოითვალა (5 * 7 = 35), მაგრამ ჩვენ არ გამოვიყენეთ ეს შედეგი, ამიტომ მივიღეთ undefined.
////
// !!console.log() მხოლოდ აჩენს შედეგს, ხოლო return გვაძლევს საშუალებას გამოვიყენოთ შედეგი სხვა ადგილას.
/////////////
// return ამბობს: „დააბრუნე ეს მნიშვნელობა ფუნქციის გარეთ“.

// კოდი, რომელიც return-ის შემდეგ იქნება, არ შესრულდება.
// მაგალითი 1: მხოლოდ console.log

// function addWithLog(a, b) {
//   console.log(a + b);
// }
// let result1 = addWithLog(3,4);
// console.log("Result1:", result1);

// // // მაგალითი 2: return-ის გამოყენებით
// function addWithReturn(a, b) {
//   return a + b;
  
// }

// let result2 = addWithReturn(3, 4);
// console.log("Result2:", result2);

////////////
// return– ის შემდეგ დაწერილი კოდი არ შესრულდება;
// მაგალითი:

// function rectangleArea(width, height) {
//   if (width < 0 || height < 0) {
//     return 'Width and height must be positive!';
//   }

//   return width * height;
// }

// console.log(rectangleArea(-5, 7));
// console.log(rectangleArea(5, 7));

/////////////////////////////////////////////////
// სავარჯიშო
// გვჭირდება ოფისისთვის მონიტორების შეკვეთა, სადაც მაგიდები გრიდისებურად არის განლაგებული X*Y. ამ შემთხვევაში, ფუნქცია დაგვეხმარება საჭირო მონიტორების რაოდენობის გამოთვლაში.

// შექმენი ფუნქცია monitorCount(), რომელსაც აქვს ორი პარამეტრი:

// I-  rows,  II- columns

// ფუნქციის სხეულში გამოთვალე მონიტორების რაოდენობა rows * columns-ით და დააბრუნე ეს მნიშვნელობა return-ის გამოყენებით.

// ოფისში გვაქვს 5 რიგი და 4 სვეტი.
// შექმენი ცვლადი numOfMonitors და გადეცი მნიშვნელობა ფუნქციის გამოძახებით:
// რათა დავრწმუნდეთ, რომ ფუნქცია სწორად მუშაობს, დაბეჭდე numOfMonitors კონსოლში.
////////////////////////////////////////////////////////

// Helper Functions/

// შეგვიძლია ერთ ფუნქციაში გამოვიყენოთ სხვა ფუნქციის return-ებული მნიშვნელობა.

// მაგალითი: ცელსიუსიდან ფარენჰაიტზე გადაყვანა

// function multiplyByNineFifths(number) {
//   return number * (9/5);
// };

// function getFahrenheit(celsius) {
//   return multiplyByNineFifths(celsius) + 32;
// };

// getFahrenheit(15);

// ///////////////////////////////////
// ჩვენ შევქმნეთ ფუნქცია, რომელიც ითვლის ოფისისთვის საჭირო მონიტორების რაოდენობას.
// ახლა შევქმნათ სხვა ფუნქცია, რომელიც გამოიყენებს monitorCount - ს, რათა გამოთვალოს მონიტორების საერთო ღირებულება.

// შექმენი ფუნქცია costOfMonitors(rows, columns), რომელიც გამოიყენებს monitorCount()–ს და დააბრუნებს მონიტორების საერთო ღირებულებას (ერთი მონიტორი = 200).
// გამოძახების შემდეგ შეინახე შედეგი ცვლადში totalCost და დაბეჭდე კონსოლში.

////////////////////////////////////////////
//
// 2– Function Expressions
//
//
// const greet = function(name) {     //ES6 შემდეგ ხშირად const-ით
//   console.log("Hello, " + name + "!");
// };
// greet("Nino");

// განსხვავება function declaration-თან: Function expressions არ იჰოისტებიან, ამიტომ ვერ გამოვიძახებთ ფუნქციას დეკლარაციამდე.

//////////////////////////////////
// სავარჯიშო

// წარმოიდგინე, რომ გვაქვს მცენარე, რომელსაც კვირაში ერთხელ, ოთხშაბათობით უნდა მორწყვა.
// შეგვიძლია შევქმნათ ფუნქცია, რომელიც დაგვეხმარება კვირის დღის შემოწმებაში და გვითხრას მცენარეს წყალი სჭირდება თუ არა.

// შექმენი ცვლადი სახელად plantNeedsWater.
// მიანიჭე ანონიმური ფუნქცია, რომელიც მიიღებს პარამეტრს day-ს.

// შეამოწმე თუ  day === 'შაბათი' ფუნქციამ უნდა დააბრუნოს true.
// სხვა დღეებში, რომლებიც არ არის 'შაბათი', plantNeedsWater() უნდა დააბრუნოს false:
// გამოძახე plantNeedsWater() და გადაეცი 'Tuesday' არგუმენტად.
// გავამოწმოთ, რომ plantNeedsWater() აბრუნებს მოსალოდნელ მნიშვნელობას:
// დაბეჭდე plantNeedsWater('Tuesday') კონსოლში.
//////////////////////////////////////////////////

// 3 – //Arrow Functions – ES6
// მთავარი წესები:
//////////////////////////////////////
// 1 პარამეტრების გამოყენება
// მაგალითი — ჩვეულებრივი ფუნქცია:
// function add(a, b) {
//   return a + b;
// }

// იგივე Arrow function-ით:
// const add = (a, b) => {
//   return a + b;
// };
// // თუ ფუნქციას აქვს მხოლოდ ერთი პარამეტრი, არ არის საჭირო ( )-ში ჩასმა.
// // ერთი პარამეტრი
// const checkWeight = (weight) => {
//   console.log(`Baggage weight: ${weight} kg`);
// };
// checkWeight(25);
// // პარამეტრების გარეშე
// const printHello = () => {
//   console.log("hello");
// };
// printHello();

// // თუ პარამეტრები არის 0 ან 2 და მეტი, აუცილებელია ( ).
// // ორი პარამეტრი
// const sum = (a, b) => {
//   return a + b;
// };
// console.log(sum(2, 5));
// ///

// //  ფუნქციის სხეული

// // თუ სხეული მხოლოდ ერთი ხაზია, { } არ არის საჭირო.

// // ერთ ხაზში შეფასებული მნიშვნელობა ავტომატურად ბრუნდება (implicit return), შესაბამისად return-ის გამოყენებაც საჭირო არაა.

// Concise Body Arrow Functions (Arrow ფუნქციების მოკლე ფორმა)

// JavaScript გვთავაზობს arrow function-ის რამდენიმე უფრო მოკლე ვერსიას. ყველაზე მოკლე ფორმა ცნობილია როგორც concise body.
////////////////////////////////
// ჩვეულებრივი arrow ფუნქცია
// const squareNum = (num) => {
//   return num * num;
// };

// // concise body ფორმა
// const squareNum = (num) => num * num;
//////////////////////////////////////////////

// სავარჯიშო
//  გადააკეთე plantNeedsWater() concise body ფორმატში.
// უკვე შემოკლებულია  if/else ტერნარული ოპერატორის (ternary operator) გამოყენებით, რათა კოდი ერთ ხაზში შევიდეს.
//
//
// const plantNeedsWater = (day) => {
//   return day === "Wednesday" ? true : false;
// };

/////////////////////////////////////////////////////
// დავალება  ხილის წვენის მაღაზია
// სიტუაცია:

// თქვენი მაღაზია ყიდის ხილის წვენს.

// თითო ბოთლის ფასი: 2.5 ლარი.

// მომხმარებელი იხდის გარკვეულ თანხას.

// შექმენი ფუნქცია, რომელიც გამოითვლის:

// რამდენი მთელი ბოთლი შეუძლია იყიდოს მომხმარებელმა;

// რამდენი იქნება უკან დასაბრუნებელი თანხა (ხურდა).

// ინსტრუქცია:

// შექმენით ფუნქცია calculateJuice რომელიც იღებს პარამეტრად money (მომხმარებლის მიერ გადახდილი).

// განსაზღვრეთ ბოთლის ფასი = 2.5 ლარი.

// გამოითვალეთ:

// numberOfBottles = მთლიანი ბოთლების რაოდენობა, რომელიც შეუძლია მომხმარებლეს ყიდვას.

// change = თანხა, რაც დარჩება, ბოთლების ყიდვის შემდეგ.

// დაბეჭდეთ კონსოლში შემდეგი ტექსტი: "გადახდილი თანხა შეადგენს money ლარს. თქვენ შეგიძლიათ იყიდოთ numberOfBottles ბოთლი წვენი, დარჩენილი თანხა შეადგენს change ლარს."
// გამოცადეთ ფუნქცია სხვადასხვა თანხებით

// გართულებული ვერსია – რომელიც შეიძლება გამოიყენო სხვადასხვა სიტუაციაში.

// ახლა გადააკეთეთ თქვენი calculateJuice ფუნქცია უფრო პროფესიულად: შეგიძლია რომ შექმნა 2 დამოუკიდებელი ფუნქცია, რომლებიც გამოითვლის
//   a) calculateBottles(startingMoney, costPerBottle) - აბრუნებს მთლიანი ბოთლების რაოდენობას.

//    b) calculateChange(startingMoney, costPerBottle) - აბრუნებს დარჩენილ change-ს.

// 2. შეცვალეთ getJuice ფუნქცია (ან calculateJuice), რომ ის გამოიყენებდეს ზემოთ შექმნილ ფუნქციებს, ანუ გამოიძახოს calculateBottles და calculateChange, და შეაგროვოს შედეგები.

// 3. დაბეჭდეთ კონსოლში მაგალითად:
// "გადახდილი თანხა შეადგენს X ლარს. თქვენ შეგიძლიათ იყიდოთ Y ბოთლი წვენი, დარჩენილი თანხა შეადგენს Z ლარს."
// სადაც X არის გადახდილი თანხა, Y ბოთლების რაოდენობა (calculateBottles-ის შედეგი), Z change (calculateChange-ის შედეგი).

// 4. გამოიყენეთ პარამეტრები ფასი (costPerBottle) და გადახდილი თანხა (money), რათა ფუნქცია იყოს უფრო მოქნილი.

// მიზანი: ნახოთ როგორ შეგიძლიათ გამოიყენოთ ერთი ფუნქციის შედეგი
// მეორეში, როგორ დავაბრუნოთ მნიშვნელობა return-ით და შემდეგ გამოიყენოთ სხვა ფუნქციაში.

//////////////////////////////////////////
// დავალება: Guess the Number

// მიზანი:
// შეადგინე მარტივი JavaScript პროგრამა, რომელიც შემთხვევით აგენერირებს რიცხვს 1–10 შორის და მომხმარებელს აჩვენებს, გამოიცნო თუ არა ეს რიცხვი.

// ინსტრუქცია
// შექმენი შემთხვევითი რიცხვი – გამოიყენე Math.random() და Math.floor().
// შენს კოდში ეს რიცხვი იქნება კომპიუტერის არჩევანი.

// შექმენი ფუნქცია  guessNumber , გადაეცი პარამეტრი – რიცხვი, რომელიც მომხმარებელმა აირჩია.

// შედარების ლოგიკა
// თუ მომხმარებელი გამოიცნობს რიცხვს –  კონსოლში დაწერე "You guessed right!"

// თუ არა → კონსოლში დაწერე "Try again"

// შედეგის ჩვენება

// კონსოლში გამოიტანე:// მომხმარებლის მიერ არჩეული რიცხვი, კომპიუტერის რიცხვი,

// შედეგი ("You guessed right!" ან "Try again")

// გამოძახე ფუნქცია რამდენიმე განსხვავებული რიცხვით, რომ შეამოწმო მუშაობა.

//////////////////////////////////
// დავალება
// ამ დავალებაში თქვენ უნდა შექმნათ ფუნქცია, რომელიც გეტყვის, რამდენი დღე, კვირა და თვე გაქვთ დარჩენილი, თუ 100 წლისა იცოცხლებთ.

// ფუნქცია მიიღებს თქვენს ასაკს, როგორც პარამეტრს, და კონსოლში დაბეჭდავს შემდეგი ფორმატით:

// You have x days, y weeks, and z months left.

// სადაც x, y და z ჩანაცვლდება შესაბამისი გამოთვლილი მნიშვნელობებით.

// შენიშვნა:

// ამ დავალებისთვის წარმოიდგინეთ, რომ
// წელიწადში არის 365 დღე, 52 კვირა და 12 თვე.

// მაგალითი:

// Example Input

// lifeInWeeks(56)

// Example Output

// You have 12410 days, 1768 weeks, and 408 months left.
//

/////////////////////////////////////////////////////////
// ბლოკები და სკოპი (Blocks & Scope)

// ბლოკი არის კოდი, რომელიც მოთავსებულია ფიგურულ ფრჩხილებში {}.
// ბლოკი ქმნის ლოკალურ სკოპს (local scope).

// {
//   let x = 10;
//   console.log(x);
// }
/////////////////////////////////////
// გლობალური სკოპი

// გლობალურ სკოპში, ცვლადები გამოცხადებულია ბლოკების გარეთ.
// ასეთი ცვლადები ეწოდება გლობალური ცვლადები.

// const color = "blue";
// const returnSkyColor = () => {
//   return color;
// };
// console.log(returnSkyColor());
////////////////////////////////////////////

// სავარჯიშო
// გამოცხადე 3 ცვლადი .
// 1)satellite   'The Moon';
// 2) galaxy 'The Milky Way';
// 3) stars  'North Star'
//  შემდეგ შექმენი ფუნქცია – callMyNightSky, დააბრუნე ტექსტი
// 'Night Sky: satellite , stars , and galaxy; – ტექსტში გამოიყენე შესაბამისი ცვლადები.
//  გამოიძახე ფუნქცია კონსოლ ლოგის საშუალებით.

///////////////////////////////////////
// ბლოკის სკოპი –ლოკალური ცვლადები

// როდესაც ცვლადი გამოცხადებულია ბლოკის შიგნით, მასზე წვდომა შესაძლებელია მხოლოდ იმ კოდში, რომელიც მოთავსებულია ამ ფიგურულ ფრჩხილებში {}.

// const logSkyColor = () => {
//   let color = 'blue';
//   console.log(color);
// };

// logSkyColor();
// console.log(color);

///////////////////////////////////////////
// სკოპის დაბინძურება (Scope Pollution)
//
// შეიძლება იდეალურად მოგვეჩვენოს, რომ ცვლადები ყოველთვის გლობალურად ხელმისაწვდომი იყოს, მაგრამ ძალიან ბევრი გლობალური ცვლადი პროგრამაში შეიძლება პრობლემები გამოიწვიოს.

// როდესაც გლობალურ ცვლადებს ვაცხადებთ, ისინი ხვდებიან გლობალურ ნეიმსპეისში (global namespace).
// გლობალური ნეიმსპეისი საშუალებას აძლევს ამ ცვლადებს, რომ პროგრამის ნებისმიერი ადგილიდან იყოს ხელმისაწვდომი.

// ეს ცვლადები პროგრამის დასრულებამდე იქ რჩება, რაც ნიშნავს, რომ გლობალური ნეიმსპეისი შეიძლება ძალიან სწრაფად გადაიტვირთოს.

// Scope Pollution (სკოპის დაბინძურება) ხდება მაშინ, როცა:

// ძალიან ბევრი ცვლადი გვაქვს გლობალურ ნეიმსპეისში, ან

// ცვლადებს სხვადასხვა სკოპში ვიყენებთ გადაფარვით.

// ეს ართულებს სხვადასხვა ცვლადის კონტროლს და ხშირად იწვევს დაუგეგმავ შეცდომებს.
// მაგალითად, გლობალური ცვლადები შეიძლება დაემთხვას ლოკალურ ცვლადებს, რაც კოდში მოულოდნელ ქცევას გამოიწვევს.

// მაგალითი Scope Pollution-ზე:

// let num = 50;

// const logNum = () => {
//   num = 100; // ყურადღება მიაქციე ამ ხაზს
//   console.log(num);
// };

// logNum();
// console.log(num);

// ეს ცვლილება გლობალურ ცვლადზე მოქმედებს.

// შეცდომა არ გამოვა, მაგრამ თუ მოგვიანებით ისევ გამოვიყენებთ num-ს, უნებლიედ უკვე შეცვლილ მნიშვნელობას დავხვდებით.

// საუკეთესო პრაქტიკა:
// გლობალური სკოპის გამოყენება მხოლოდ მაშინ, როცა ნამდვილად აუცილებელია.
// სხვა შემთხვევაში, ცვლადები ლოკალურ ბლოკებში გამოაცხადეთ (let ან const), რათა თავიდან აიცილოთ დაბინძურება და გაუგებრობა.
///////////////////////////////////////////////
// მაგალითი
// const satellite = 'The Moon';
// const galaxy = 'The Milky Way';
// let stars = 'North Star';

// const callMyNightSky = () => {
//   stars = 'Sirius';

// 	return 'Night Sky: ' + satellite + ', ' + stars + ', ' + galaxy;
// };

// console.log(callMyNightSky());
// console.log(stars );
// ჩვენ შევცვალეთ გლობალური ცვლადი ფუნქციის შიგნიდან, მაგრამ კოდის წაკითხვისას ეს პროცესი მარტივად გასაგები არ არის.

// რატომ არის ეს ცუდი პრაქტიკა:

// კოდის გასაგებადობა და მხარდაჭერა რთულდება.

// პროგრამის სხვა ნაწილებში შეიძლება მოულოდნელი შეცდომები გამოიწვიოს.

// რთულია იმის გაგება, სად და რატომ შეიცვალა ცვლადის მნიშვნელობა.

///////////////////////////////////////////////

// საუკეთესო პრაქტიკა
// ცვლადები გამოვაცხადოთ მაქსიმალურად შეზღუდულ სკოპში, ანუ block scope-ით.
// კოდი უფრო წაკითხვადი და ორგანიზებული იქნება — ბლოკები აშკარად დაყოფენ კოდს ცალკე სექციებად.

// უფრო გასაგები ხდება, რომელი ცვლადები რომელი ნაწილისთვის არის განკუთვნილი,
// და აღარ გვიწევს მათ ზედიზედ ყველა ხაზში კონტროლი.

// კოდი უფრო მარტივი იქნება შესანარჩუნებლად, რადგან ის მოდულარული გახდება.

// მეხსიერება დაზოგილი იქნება, რადგან ბლოკის სკოპის მქონე ცვლადები ქრებიან მას შემდეგ, რაც ბლოკი შესრულდება.~

// const logSkyColor = () => {
//   const dusk = true;
//   let color = "blue";

//   if (dusk) {
//     let color = "pink";
//     console.log(color);
//   }

//   console.log(color);
// };

// console.log(color);
// logSkyColor();
// შეჯამება:

// Block scope გვაძლევს საშუალებას ცვლადები ზუსტად იქ შევქმნათ, სადაც საჭიროა.

// თუ ცვლადი არ უნდა არსებობდეს ბლოკის გარეთ — არ გამოვაცხადოთ გლობალურად!

// ეს თავიდან აგვაცილებს global namespace-ის დაბინძურებას და გაუგებრობას კოდში.
///////////////////////////////////////
// მაგალითი~

// logVisibleLightWaves();

// const logVisibleLightWaves = () => {
//   let lightWaves = 'Moonlight';
// 	let region = 'The Arctic';

//   if (region ==='The Arctic' ){
//     let lightWaves  = 'Northern Lights'
//      console.log(lightWaves);

//   }
//   console.log(lightWaves);
// };

// logVisibleLightWaves();
/////////////////////////////////////////
// შეჯამება

// Scope (სკოპი): განსაზღვრავს, სად არის ცვლადები ხელმისაწვდომი პროგრამაში. სკოპი დამოკიდებულია იმაზე, სად და როგორ არის ცვლადი გამოცხადებული.

// Blocks (ბლოკები): კოდის ნაწილი, რომლებიც მოთავსებულია ფიგურულ ფრჩხილებში {}.

// Global scope (გლობალური სკოპი): კონტექსტი, სადაც ცვლადები ხელმისაწვდომია პროგრამის ყველა ნაწილში.

// Global variables (გლობალური ცვლადები): ცვლადები, რომლებიც არსებობს გლობალურ სკოპში.

// Block scope (ბლოკის სკოპი): ცვლადები ხელმისაწვდომია მხოლოდ იმ ბლოკში, სადაც ისინი გამოცხადდნენ.

// Local variables (ლოკალური ცვლადები): ცვლადები, რომლებიც არსებობს ბლოკის სკოპში.

// Global namespace (გლობალური ნეიმსპეისი): სივრცე კოდში, რომელიც შეიცავს გლობალურად სკოპირებულ ინფორმაციას.

// Scope pollution (სკოპის დაბინძურება): ხდება, როცა ძალიან ბევრი ცვლადი არსებობს ერთ ნეიმსპეისში ან ცვლადების სახელები განმეორდება.
script.js
ნაჩვენებია script.js